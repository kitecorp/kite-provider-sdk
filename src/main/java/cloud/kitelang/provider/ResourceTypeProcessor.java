package cloud.kitelang.provider;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.io.Writer;
import java.util.HashSet;
import java.util.Set;

/**
 * Annotation processor that discovers ResourceTypeHandler classes at compile time.
 * Generates META-INF/kite/resource-types.txt listing all ResourceTypeHandler subclasses
 * whose resource class has @TypeName annotation.
 *
 * <p>This enables GraalVM native-image compatibility by avoiding runtime classpath scanning.</p>
 */
@SupportedAnnotationTypes("cloud.kitelang.api.annotations.TypeName")
@SupportedSourceVersion(SourceVersion.RELEASE_21)
public class ResourceTypeProcessor extends AbstractProcessor {

    private static final String MANIFEST_PATH = "META-INF/kite/resource-types.txt";
    private final Set<String> resourceTypeClasses = new HashSet<>();

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (var annotation : annotations) {
            for (Element element : roundEnv.getElementsAnnotatedWith(annotation)) {
                if (element instanceof TypeElement resourceClass) {
                    // Find ResourceTypeHandler<ThisClass> in the same package
                    findResourceTypeFor(resourceClass);
                }
            }
        }

        // Write manifest on final round
        if (roundEnv.processingOver() && !resourceTypeClasses.isEmpty()) {
            writeManifest();
        }

        return false; // Don't claim the annotation
    }

    /**
     * Find a ResourceTypeHandler class that handles the given resource class.
     * Looks for classes that extend ResourceTypeHandler<ResourceClass>.
     */
    private void findResourceTypeFor(TypeElement resourceClass) {
        var packageElement = processingEnv.getElementUtils().getPackageOf(resourceClass);
        var resourceClassName = resourceClass.getQualifiedName().toString();

        // Look for classes in the same package that extend ResourceTypeHandler<resourceClass>
        for (Element sibling : packageElement.getEnclosedElements()) {
            if (sibling instanceof TypeElement candidate) {
                if (isResourceTypeFor(candidate, resourceClassName)) {
                    resourceTypeClasses.add(candidate.getQualifiedName().toString());
                    processingEnv.getMessager().printMessage(
                            Diagnostic.Kind.NOTE,
                            "Found ResourceTypeHandler: " + candidate.getQualifiedName() + " for " + resourceClassName);
                }
            }
        }
    }

    /**
     * Check if candidate extends ResourceTypeHandler<resourceClassName>.
     */
    private boolean isResourceTypeFor(TypeElement candidate, String resourceClassName) {
        TypeMirror superclass = candidate.getSuperclass();

        while (superclass instanceof DeclaredType declaredType) {
            var typeElement = (TypeElement) declaredType.asElement();
            var typeName = typeElement.getQualifiedName().toString();

            if (typeName.equals("cloud.kitelang.provider.ResourceTypeHandler")) {
                // Check type argument
                var typeArgs = declaredType.getTypeArguments();
                if (!typeArgs.isEmpty()) {
                    var typeArg = typeArgs.get(0);
                    if (typeArg instanceof DeclaredType argType) {
                        var argElement = (TypeElement) argType.asElement();
                        return argElement.getQualifiedName().toString().equals(resourceClassName);
                    }
                }
                return false;
            }

            // Walk up the hierarchy
            superclass = typeElement.getSuperclass();
        }

        return false;
    }

    /**
     * Write the manifest file with discovered ResourceTypeHandler classes.
     */
    private void writeManifest() {
        try {
            FileObject file = processingEnv.getFiler().createResource(
                    StandardLocation.CLASS_OUTPUT, "", MANIFEST_PATH);

            try (Writer writer = file.openWriter()) {
                writer.write("# Generated by ResourceTypeProcessor - do not edit\n");
                for (String className : resourceTypeClasses) {
                    writer.write(className);
                    writer.write("\n");
                }
            }

            processingEnv.getMessager().printMessage(
                    Diagnostic.Kind.NOTE,
                    "Generated " + MANIFEST_PATH + " with " + resourceTypeClasses.size() + " resource types");

        } catch (IOException e) {
            processingEnv.getMessager().printMessage(
                    Diagnostic.Kind.ERROR,
                    "Failed to write resource types manifest: " + e.getMessage());
        }
    }
}
