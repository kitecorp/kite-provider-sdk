package cloud.kitelang.provider;

import cloud.kitelang.api.annotations.TypeName;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Getter;
import lombok.extern.log4j.Log4j2;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.*;

/**
 * Base class for Kite provider implementations.
 * Extend this class to create a provider that can be loaded by the Kite engine.
 *
 * <p>Auto-discovery is enabled by default. It first checks for a manifest file
 * (META-INF/kite/resource-types.txt) generated by {@link ResourceTypeProcessor},
 * then falls back to runtime classpath scanning.</p>
 *
 * <p>Provider name and version are automatically read from
 * META-INF/kite/provider.json (generated by the kite-provider-gradle-plugin).
 * You can also specify them explicitly if needed.</p>
 *
 * <p>Example usage:</p>
 * <pre>{@code
 * public class FilesProvider extends KiteProvider {
 *     public FilesProvider() {
 *         // Name and version auto-read from provider-info.properties
 *         // ResourceTypes are auto-discovered
 *     }
 *
 *     public static void main(String[] args) throws Exception {
 *         ProviderServer.serve(new FilesProvider());
 *     }
 * }
 * }</pre>
 */
@Log4j2
@Getter
public abstract class KiteProvider {
    private static final String PROVIDER_JSON_PATH = "META-INF/kite/provider.json";
    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    private final String name;
    private final String version;
    private final Map<String, ResourceTypeHandler<?>> resourceTypes = new HashMap<>();
    private Object config;

    /**
     * Create a new provider with auto-detected name and version.
     * Name and version are read from META-INF/kite/provider.json,
     * which is generated by the kite-provider-gradle-plugin.
     */
    protected KiteProvider() {
        this(true);
    }

    /**
     * Create a new provider with auto-detected name and version.
     *
     * @param autoDiscover If autodiscovery of resource types should be enabled
     */
    protected KiteProvider(boolean autoDiscover) {
        var info = loadProviderInfo();
        this.name = info != null ? info.path("name").asText(null) : null;
        this.version = info != null ? info.path("version").asText(null) : null;

        if (this.name == null || this.version == null) {
            throw new IllegalStateException(
                    "Could not read provider name/version from " + PROVIDER_JSON_PATH + ". " +
                    "Ensure you're using the kite-provider-gradle-plugin, or use the constructor that accepts name and version.");
        }

        log.debug("Provider info loaded: name={}, version={}", name, version);

        if (autoDiscover) {
            discoverResourcesFromManifest();
        }
    }

    /**
     * Create a new provider with explicit name and version.
     *
     * @param name    The provider name (e.g., "aws", "files")
     * @param version The provider version (semver)
     * @deprecated Use the no-arg constructor with kite-provider-gradle-plugin instead
     */
    @Deprecated
    protected KiteProvider(String name, String version) {
        this(name, version, true);
    }

    /**
     * Create a new provider with explicit name and version.
     *
     * @param name    The provider name (e.g., "aws", "files")
     * @param version The provider version (semver)
     * @param autoDiscover If autodiscovery should be enabled. Enabled when not specified
     * @deprecated Use the no-arg constructor with kite-provider-gradle-plugin instead
     */
    @Deprecated
    protected KiteProvider(String name, String version, boolean autoDiscover) {
        this.name = name;
        this.version = version;
        if (autoDiscover) {
            // Try manifest first (GraalVM compatible), fall back to runtime scanning
            discoverResourcesFromManifest();
        }
    }

    /**
     * Load provider info from the JSON file generated by the Gradle plugin.
     */
    private static JsonNode loadProviderInfo() {
        var classLoader = Thread.currentThread().getContextClassLoader();
        var resource = classLoader.getResourceAsStream(PROVIDER_JSON_PATH);

        if (resource != null) {
            try (resource) {
                return OBJECT_MAPPER.readTree(resource);
            } catch (IOException e) {
                log.warn("Failed to load {}: {}", PROVIDER_JSON_PATH, e.getMessage());
            }
        }

        return null;
    }

    /**
     * Auto-discover and register all ResourceTypeHandler classes in the provider's package.
     * Scans for classes that:
     * - Extend ResourceTypeHandler
     * - Have a no-arg constructor
     * - Have a resource class annotated with @TypeName
     * <p>
     * Classes without @TypeName are silently ignored.
     */
    protected void discoverResources() {
        discoverResources(getClass().getPackageName());
    }

    /**
     * Auto-discover and register all ResourceTypeHandler classes in the specified package.
     *
     * @param packageName The package to scan for ResourceTypeHandler classes
     */
    protected void discoverResources(String packageName) {
        log.debug("Discovering resources in package: {}", packageName);

        try {
            var resourceTypeClasses = findResourceTypeClasses(packageName);

            for (var clazz : resourceTypeClasses) {
                try {
                    var resourceType = clazz.getDeclaredConstructor().newInstance();
                    registerResource(resourceType);
                } catch (NoSuchMethodException e) {
                    log.debug("Skipping {} - no no-arg constructor", clazz.getName());
                } catch (Exception e) {
                    log.warn("Failed to instantiate {}: {}", clazz.getName(), e.getMessage());
                }
            }

            log.info("Discovered {} resource types in package {}", resourceTypes.size(), packageName);
        } catch (Exception e) {
            log.error("Failed to discover resources in package {}", packageName, e);
        }
    }

    /**
     * Discover and register ResourceTypeHandler classes from a manifest file.
     * This method is GraalVM native-image compatible as it doesn't use runtime classpath scanning.
     *
     * <p>Create META-INF/kite/resource-types.txt with one ResourceTypeHandler class name per line.</p>
     */
    @SuppressWarnings("unchecked")
    protected void discoverResourcesFromManifest() {
        var manifestPath = "META-INF/kite/resource-types.txt";
        var classLoader = Thread.currentThread().getContextClassLoader();
        var resource = classLoader.getResourceAsStream(manifestPath);

        if (resource == null) {
            log.debug("No resource types manifest found at {}, falling back to runtime discovery", manifestPath);
            discoverResources();
            return;
        }

        try (var reader = new BufferedReader(new InputStreamReader(resource, StandardCharsets.UTF_8))) {
            String className;
            while ((className = reader.readLine()) != null) {
                className = className.trim();
                if (className.isEmpty() || className.startsWith("#")) {
                    continue;
                }

                try {
                    var clazz = (Class<? extends ResourceTypeHandler<?>>) classLoader.loadClass(className);
                    var resourceType = clazz.getDeclaredConstructor().newInstance();
                    registerResource(resourceType);
                } catch (Exception e) {
                    log.warn("Failed to load ResourceTypeHandler {}: {}", className, e.getMessage());
                }
            }

            log.info("Loaded {} resource types from manifest", resourceTypes.size());
        } catch (IOException e) {
            log.error("Failed to read resource types manifest", e);
        }
    }

    /**
     * Find all ResourceTypeHandler subclasses in a package.
     */
    @SuppressWarnings("unchecked")
    private List<Class<? extends ResourceTypeHandler<?>>> findResourceTypeClasses(String packageName) throws IOException, ClassNotFoundException {
        var result = new ArrayList<Class<? extends ResourceTypeHandler<?>>>();
        var classLoader = Thread.currentThread().getContextClassLoader();
        var path = packageName.replace('.', '/');
        Enumeration<URL> resources = classLoader.getResources(path);

        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            File directory = new File(resource.getFile());

            if (directory.exists()) {
                findClassesInDirectory(directory, packageName, result, classLoader);
            }
        }

        return result;
    }

    /**
     * Recursively find ResourceTypeHandler classes in a directory.
     */
    @SuppressWarnings("unchecked")
    private void findClassesInDirectory(
            File directory,
            String packageName,
            List<Class<? extends ResourceTypeHandler<?>>> result,
            ClassLoader classLoader) throws ClassNotFoundException {

        File[] files = directory.listFiles();
        if (files == null) return;

        for (File file : files) {
            if (file.isDirectory()) {
                findClassesInDirectory(file, packageName + "." + file.getName(), result, classLoader);
            } else if (file.getName().endsWith(".class")) {
                String className = packageName + '.' + file.getName().substring(0, file.getName().length() - 6);

                try {
                    Class<?> clazz = classLoader.loadClass(className);

                    // Check if it's a concrete ResourceTypeHandler subclass
                    if (ResourceTypeHandler.class.isAssignableFrom(clazz)
                        && !Modifier.isAbstract(clazz.getModifiers())
                        && clazz != ResourceTypeHandler.class) {

                        result.add((Class<? extends ResourceTypeHandler<?>>) clazz);
                        log.debug("Found ResourceTypeHandler: {}", className);
                    }
                } catch (NoClassDefFoundError e) {
                    log.debug("Skipping {} - missing dependency", className);
                }
            }
        }
    }

    /**
     * Register a resource type with this provider using explicit type name.
     *
     * @param typeName     The resource type name (e.g., "S3Bucket", "File")
     * @param resourceType The resource type definition
     */
    protected <T> void registerResource(String typeName, ResourceTypeHandler<T> resourceType) {
        resourceTypes.put(typeName, resourceType);
        log.debug("Registered resource type: {}", typeName);
    }

    /**
     * Register a resource type with this provider.
     * The type name is auto-discovered from the @TypeName annotation on the resource class.
     * If @TypeName is missing, the resource is silently ignored.
     *
     * @param resourceType The resource type definition
     */
    protected <T> void registerResource(ResourceTypeHandler<T> resourceType) {
        var resourceClass = resourceType.getResourceClass();
        var typeNameAnnotation = resourceClass.getAnnotation(TypeName.class);

        if (typeNameAnnotation == null) {
            log.debug("Skipping resource type {} - no @TypeName annotation", resourceClass.getName());
            return;
        }

        var typeName = typeNameAnnotation.value();
        resourceTypes.put(typeName, resourceType);
        log.debug("Registered resource type: {} (from @TypeName)", typeName);
    }

    /**
     * Get a registered resource type by name.
     *
     * @param typeName The resource type name
     * @return The resource type, or null if not found
     */
    @SuppressWarnings("unchecked")
    public <T> ResourceTypeHandler<T> getResourceType(String typeName) {
        return (ResourceTypeHandler<T>) resourceTypes.get(typeName);
    }

    /**
     * Configure the provider with runtime configuration.
     * Override this method to handle provider-level configuration.
     *
     * @param configuration The provider configuration
     */
    public void configure(Object configuration) {
        this.config = configuration;
        log.debug("Provider {} configured", name);
    }

    /**
     * Called when the provider is being stopped.
     * Override to perform cleanup operations.
     */
    public void stop() {
        log.debug("Provider {} stopping", name);
    }
}
